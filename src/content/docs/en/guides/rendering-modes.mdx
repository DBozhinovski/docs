---
title: "Rendering Modes"
i18nReady: false
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro';
import RecipeLinks from '~/components/RecipeLinks.astro';

Your Astro project code must be **rendered** to HTML in order to be displayed on the web. 

Astro pages, routes and API endpoints can be either [pre-rendered at build time](#pre-rendered) or [rendered on demand by a server](#on-demand-rendered) when a route is requested. With [Astro islands](/en/concepts/islands/), you can also include some client-side rendering when necessary.

In Astro, most of the processing occurs on the server, instead of in the browser. This generally makes your site or app faster than client-side rendering when viewed on less-powerful devices or on slower internet connections. Server-rendered HTML is fast, SEO friendly, and accessible by default.

## `output` options

You can configure how your pages are rendered in your [`output` configuration](/en/reference/configuration-reference/#output).

### Pre-rendered

The **default rendering mode is __`output: 'static'`__**, which creates the HTML for all your page routes at build time. In this mode, **your entire site will be pre-rendered** and the server will have all pages built ahead of time and ready to send to the browser. The same HTML document is sent to the browser for every visitor, and a full-site rebuild is required to update the contents of the page. This method is also known as **static site generation (SSG)**. 

By default, all Astro projects are pre-rendered at build time (statically-generated) to provide the most lightweight browser experience. The browser does not need to wait for any HTML to build because the server does not need to generate your pages. Your site is not dependent on the performance of a backend data source, and once built, will remain available to visitors as long as your server is functioning.

Static sites can include [Astro islands](/en/concepts/islands/) for interactive UI components (or even entire embedded client-side rendered apps!) written in the [UI framework of your choice](/en/core-concepts/framework-components/) in an otherwise static, pre-rendered page.

Astro's [View Transitions API](/en/guides/view-transitions/) are also available in `static` mode for animation and state persistence across page navigation. Static sites can also use [middleware](/en/guides/middleware/) to intercept and transform response data from a request.

:::tip
Astro's default `static` mode is a powerful, modern-feeling choice for content-heavy sites that update infrequently, and display the same page content to all visitors.
:::

### On-demand rendered

Astro's other two output modes can be configured to enable **on-demand rendering of some or all of your pages, routes or API endpoints**:
  - __`output: 'server'`__ for highly dynamic sites with most or all on-demand routes.
  - __`output: 'hybrid'`__ for mostly static sites with some on-demand routes. 
  
Since they are generated per visit, these routes can be customized for each viewer. For example, a page rendered on demand can show a logged-in user their account information or display freshly updated data without requiring a full-site rebuild. On-demand rendering on the server at request time is also known as **server-side rendering (SSR)**.

Consider enabling `server` or `hybrid` mode in your Astro project if you need the following:

- **API endpoints**: Create specific pages that function as API endpoints for tasks like database access, authentication, and authorization while keeping sensitive data hidden from the client.

- **Protected pages**: Restrict access to a page based on user privileges, by handling user access on the server.

- **Frequently changing content**: Generate individual pages without requiring a static rebuild of your site. This is useful when the content of a page updates frequently, for example displaying data from an API called dynamically with `fetch()`.

Both `server` and `hybrid` output modes allow you to include [Astro islands](/en/concepts/islands/) for interactivity (or even entire embedded client-side rendered apps!) in your choice of [UI frameworks](/en/core-concepts/framework-components/). With [middleware](/en/guides/middleware/) and Astro's [View Transitions API](/en/guides/view-transitions/) for animations and preserving state across route navigations, even highly interactive apps are possible.

:::tip
On demand server-rendering in Astro provides a true app experience without the JavaScript overhead of a traditional client-side, single-page application.
:::

## Enable on-demand server rendering

Both `server` and `hybrid` mode allow you to take advantage of static site performance by pre-rendering whenever possible, whether you have an entirely dynamic app or a mostly static site that needs on-demand rendering only for select routes.

Choose the `output` option that represents how **most** of your pages and routes will be rendered:

- __`output: 'server'`__: On-demand rendered by default. Use this when most or all of your site or app should be server-rendered on request. Any individual page or endpoint can *opt-in* to pre-rendering.
- __`output: 'hybrid'`__: Pre-rendered to HTML by default. Use this when most of your site should be static. Any individual page or endpoint can *opt-out* of pre-rendering.
 
Because the server will need to generate at least some pages on demand, both of these modes require you to [add an adapter](#add-an-adapter) to carry out the server functions.

### Configure `server` or `hybrid`

To enable on-demand rendering, first update your `output` configuration to one of the two server-rendered modes.

For example, for a highly dynamic app where every page is rendered on demand, add `output: 'server'` to your Astro config: 

```js ins={5} title="astro.config.mjs"
import { defineConfig } from 'astro/config';
import nodejs from '@astrojs/nodejs';

export default defineConfig({
  output: 'server',
});
```

You can then override the default on-demand rendering of `server` mode on any page or route by exporting `const prerender = true`:

```astro title="src/pages/my-static-page.astro" ins={2}
---
export const prerender = true;
// ...
---
<html>
  <!-- Static, pre-rendered page here... -->
</html>
```

### Opting-in to pre-rendering in `server` mode

For a mostly server-rendered app configured as `output: server`, add `export const prerender = true` to any page or route to pre-render a static page or endpoint:

```astro title="src/pages/mypage.astro" {2}
---
export const prerender = true;
// ...
---
<html>
  <!-- Static, pre-rendered page here... -->
</html>
```

```mdx title="src/pages/mypage.mdx" {5}
---
layout: '../layouts/markdown.astro'
title: 'My page'
---
export const prerender = true;

# This is my static, pre-rendered page
```

```js title="src/pages/myendpoint.js" {1}
export const prerender = true;

export async function GET() {
  return {
    body: JSON.stringify({ message: `This is my static endpoint` }),
  };
}
```

### Opting out of pre-rendering in `hybrid` mode

For a mostly static site configured as `output: hybrid`, add `export const prerender = false` to any files that should be server-rendered on demand:

```js title="src/pages/randomnumber.js" {1}
export const prerender = false;

export async function GET() {
  let number = Math.random();
  return {
    body: JSON.stringify({ number, message: `Here's a random number: ${number}` }),
  };
}
```

### Add an Adapter

To deploy a project in `server` or `hybrid` mode, you also need to add an **adapter**. This is because both of these modes require a server _runtime_: the environment that runs code on the server to generate pages when they are requested. Each adapter allows Astro to output a script that runs your project on a specific runtime, such as Vercel, Netlify or Cloudflare.

You can find both [official and community adapters in our integrations directory](https://astro.build/integrations/?search=&categories%5B%5D=adapters). Choose the one that corresponds to your [deployment environment](/en/guides/deploy/).

#### `astro add` Install

You can add any of the [official adapters maintained by Astro](/en/guides/integrations-guide/#official-integrations) with the following `astro add` command. This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step. 

For example, to install the Vercel adapter, run:

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  npx astro add vercel
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  pnpm astro add vercel
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  yarn astro add vercel
  ```
  </Fragment>
</PackageManagerTabs>

#### Manual Install

You can also add an adapter manually by installing the package and updating `astro.config.mjs` yourself.

For example, to install the Vercel adapter manually:

1. Install the adapter to your project dependencies using your preferred package manager:

   <PackageManagerTabs>
     <Fragment slot="npm">
     ```shell
     npm install @astrojs/vercel
     ```
     </Fragment>
     <Fragment slot="pnpm">
     ```shell
     pnpm install @astrojs/vercel
     ```
     </Fragment>
     <Fragment slot="yarn">
     ```shell
     yarn add @astrojs/vercel
     ```
     </Fragment>
   </PackageManagerTabs>

2. [Add the adapter](/en/reference/configuration-reference/#adapter) to your `astro.config.mjs` file's import and default export, along with your desired `output` mode:

    ```js ins={3,7} {6}
    // astro.config.mjs
    import { defineConfig } from 'astro/config';
    import vercel from '@astrojs/vercel';

    export default defineConfig({
      output: 'server',
      adapter: vercel(),
    });
    ```

## On-demand rendering features

:::caution[HTML streaming]
Features that modify the [Response headers](https://developer.mozilla.org/en-US/docs/Glossary/Response_header) are only available at the **page level**. (You can't use them inside of components, including layout components.)

In an [on-demand rendering mode](#on-demand-rendered), Astro uses HTML streaming to send each component to the browser as it renders them. This makes sure your visitor sees your HTML as fast as possible, but it also means that by the time Astro runs your component code, it has already sent the Response headers and they cannot be modified.
:::

<RecipeLinks slugs={["en/recipes/streaming-improve-page-performance"]}/>

### Cookies

In `server` and `hybrid` modes, a page or API endpoint can check, set, get, and delete cookies.

The example below updates the value of a cookie for a page view counter:

```astro title="src/pages/index.astro" {4,5,9}
---
let counter = 0

if (Astro.cookies.has("counter")) {
  const cookie = Astro.cookies.get("counter")
	counter = cookie.number() + 1
}

Astro.cookies.set("counter",counter)
---
<html>
  <h1>Counter = {counter}</h1>
</html>
```

See more details about [`Astro.cookies` and the `AstroCookie` type](/en/reference/api-reference/#astrocookies) in the API reference.

### `Response`

You can also return a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) from any page using on-demand rendering. 

The example below returns a 404 on a dynamic page after looking up an id in the database:

```astro title="src/pages/[id].astro" {8-11}
---
import { getProduct } from '../api';

const product = await getProduct(Astro.params.id);

// No product found
if (!product) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found'
  });
}
---
<html>
  <!-- Page here... -->
</html>
```

### `Request`

`Astro.request` is a standard [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object. It can be used to get the `url`, `headers`, `method`, and even body of the request. In both `server` and `hybrid` mode, you can access additional information from this object for pages that are not statically-generated.

#### `Astro.request.headers`

The headers for the request are available on `Astro.request.headers`. This works like the browser's [`Request.headers`](https://developer.mozilla.org/en-US/docs/Web/API/Request/headers). It is a [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object, a Map-like object where you can retrieve headers such as the cookie.

```astro title="src/pages/index.astro" {2}
---
const cookie = Astro.request.headers.get('cookie');
// ...
---
<html>
  <!-- Page here... -->
</html>
```

#### `Astro.request.method`

The HTTP method used in the request is available as `Astro.request.method`. This works like the browser's [`Request.method`](https://developer.mozilla.org/en-US/docs/Web/API/Request/method). It returns the string representation of the HTTP method used in the request.

```astro title="src/pages/index.astro"
---
console.log(Astro.request.method) // GET (when navigated to in the browser)
---
```

See more details about [`Astro.request`](/en/reference/api-reference/#astrorequest) in the API reference.

### Server Endpoints

A server endpoint, also known as an **API route**, is a special function exported from a `.js` or `.ts` file within the `src/pages/` folder. A powerful feature of server-side rendering on demand, API routes are able to securely execute code on the server.

The function takes an [endpoint context](/en/reference/api-reference/#endpoint-context) and returns a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response). 

To learn more, see our [Endpoints Guide](/en/core-concepts/endpoints/#server-endpoints-api-routes).






{/* 

 */}
