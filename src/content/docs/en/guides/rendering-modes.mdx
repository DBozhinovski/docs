---
title: "Rendering Modes"
i18nReady: false
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro';
import Since from '~/components/Since.astro';

 Astro projects are **server-rendered**, either at build time or on demand when a route is requested. With [Astro islands](/en/concepts/islands/) and [view transitions](/en/guides/view-transitions/), you can add client-side rendering when necessary.

Exactly when and how your project is built depends on your [`output` configuration](/en/reference/configuration-reference/#output).

The default mode is `static`, which generates all your page routes at build time. This is also known as **static-site generation** (SSG). In this mode, your entire site will be pre-rendered at build time.

Astro also provides two **server-side rendering** (SSR) modes for generating routes on demand at request time:

- __`output: 'server'`__: Server-rendered by default. Use this when most or all of your site or app should be server-rendered. Any individual page or endpoint can *opt-in* to pre-rendering.
- __`output: 'hybrid'`__: Pre-rendered to HTML by default. Use this when most of your site should be static. Any individual page or endpoint can *opt-out* of pre-rendering. 

  (If your entire site will be pre-rendered with no on-demand routes, consider using `output:'static'` instead.)

## Server options

In Astro, most of the processing occurs on the server. This improves loading time and makes your site or app faster than client-side rendering when viewed on less-powerful devices or on slower internet connections. Server-rendered HTML is fast, SEO friendly, and accessible.

### Static site generation

**Static site generation (SSG)** refers to generating HTML pages during the build process, before they are requested by the client. The same HTML (and JavaScript, when client-side interactivity is needed) is sent to the browser for every visitor, and a full-site rebuild is required to update the contents of the page. 

This occurs by default in Astro, or when you have explicitly set `output: 'static'` in your configuration.

### Server-side rendering

**Server-side rendering (SSR)** refers to generating HTML pages on the server on-demand just before sending them to the client. Since they are generated per visit, these pages can be customized for each viewer. For example, this page can show a logged in user their account information or display freshly updated data without requiring a full-site rebuild.

This occurs for pages dynamically-generated on request when either `output: 'server'` or `output: 'hybrid'` is configured.

## `static` by default

All Astro projects are statically-generated by default to provide the most lightweight browser experience. The client does not need to wait for any HTML to build because the server does not need to generate your pages. Your site is not dependent on the performance of a backend data source, and once built, will remain available to visitors as long as your server is functioning.

Static sites can include [Astro islands](/en/concepts/islands/) for interactive UI components (or even entire embedded client-side rendered apps!) written in the [UI framework of your choice](/en/core-concepts/framework-components/) in an otherwise static, server-rendered page.

Astro's [View Transitions API](/en/guides/view-transitions/) are also available in `static` mode for animation and state persistence across page navigation, as well as [middleware](/en/guides/middleware/) to intercept and transform response data from a request. This makes Astro's `static` mode a powerful, modern-feeling choice for content-heavy sites that update infrequently, and display the same page content to all visitors.

## Opt in to a server mode

Server-rendering routes on request brings the advantages of fresh page content and [several other features](#ssr-features), but at a potential performance cost compared to `static` sites. Pages must be generated on demand before they can be served to the client. If data is fetched from external sources, then their speed also becomes a factor in your page load time. And, even if no data has changed, a page must still be re-generated server-side before rendering and so a caching strategy may be required.

Despite the extra complexity and potential performance issues compared to static sites, server-rendering on demand enables app-like behaviour that is more performant and more accessible than a traditional single-page JavaScript application (SPA). Astro's two server modes also allow you to pre-render individual pages whenever possible. This gives you the performance benefits of static sites for the routes that do not need to be generated on-demand. 

Server-side rendered apps can also include [Astro islands](/en/concepts/islands/) for interactivity (or even entire embedded client-side rendered apps!) in your choice of [UI frameworks](/en/core-concepts/framework-components/). With [middleware](/en/guides/middleware/) and Astro's [View Transitions API](/en/guides/view-transitions/) for animations and preserving state across route navigations, even highly interactive apps are possible.

Server-side rendering in Astro provides a true app experience without the JavaScript overhead of a traditional client-side, single-page application.

### Server mode uses

Consider enabling server-side rendering in your Astro project if you need the following:

- **API endpoints**: SSR enables you to create specific pages that function as API endpoints for tasks like database access, authentication, and authorization while keeping sensitive data hidden from the client.

- **Protected pages**: If you need to restrict access to a page based on user privileges, you can enable SSR to handle user access on the server.

- **Frequently changing content**: Enabling SSR lets you generate individual pages without requiring a static rebuild of your site. This is useful when the content of a page updates frequently, for example displaying data from an API called dynamically with `fetch`.

### Configure a server mode

Astro's two server modes ensure that you can take still advantage of static site performance by pre-rendering whenever possible, whether you have an entirely server-rendered app or a mostly static site that needs SSR only for select routes.

Both server modes require you to [add an adapter](#adding-an-adapter) to carry out the server functions.

- __`output: 'server'`__: Server-rendered by default. Use this when most or all of your site or app should be server-rendered. Any individual page or endpoint can *opt-in* to pre-rendering.
- __`output: 'hybrid'`__: Pre-rendered to HTML by default. Use this when most of your site should be static. Any individual page or endpoint can *opt-out* of pre-rendering.

To enable, update your `output` configuration to one of the two SSR modes. 

For example, to enable an entirely server-rendered app, add `output: server` to your Astro config: 

```js ins={6,7}
// astro.config.mjs
import { defineConfig } from 'astro/config';
import nodejs from '@astrojs/nodejs';

export default defineConfig({
  output: 'server',
  adapter: nodejs(),
});
```

You can then override your mode's default behavior for any page or route by exporting a value for `prerender`, either `true` or `false` as appropriate:

```astro title="src/pages/mypage.astro" {2}
---
export const prerender = true;
// ...
---
<html>
  <!-- Static, pre-rendered page here... -->
</html>
```
See more examples of [specifying rendering behavior on a per-page basis](#per-page-prerendering) for these two server options.

### Adding an Adapter

When it's time to deploy an SSR project, you also need to add an adapter. This is because SSR requires a server _runtime_: the environment that runs your server-side code. Each adapter allows Astro to output a script that runs your project on a specific runtime.

You can find both [official and community SSR adapters in our integrations directory](https://astro.build/integrations/?search=&categories%5B%5D=adapters).

#### `astro add` Install

You can add any of the official adapters with the following `astro add` command. This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step. For example, to install the Vercel adapter, run:

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  npx astro add vercel
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  pnpm astro add vercel
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  yarn astro add vercel
  ```
  </Fragment>
</PackageManagerTabs>

#### Manual Install

You can also add an adapter manually by installing the package and updating `astro.config.mjs` yourself. (See the links above for adapter-specific instructions to complete the following two steps to enable SSR.) For example, to install the Vercel adapter manually:

1. Install the adapter to your project dependencies using your preferred package manager:

   <PackageManagerTabs>
     <Fragment slot="npm">
     ```shell
     npm install @astrojs/vercel
     ```
     </Fragment>
     <Fragment slot="pnpm">
     ```shell
     pnpm install @astrojs/vercel
     ```
     </Fragment>
     <Fragment slot="yarn">
     ```shell
     yarn add @astrojs/vercel
     ```
     </Fragment>
   </PackageManagerTabs>

2. [Add the adapter](/en/reference/configuration-reference/#adapter) to your `astro.config.mjs` file's import and default export:

    ```js ins={3,6-7}
    // astro.config.mjs
    import { defineConfig } from 'astro/config';
    import vercel from '@astrojs/vercel';

    export default defineConfig({
      output: 'server',
      adapter: vercel(),
    });
    ```

## SSR Features

Astro is static-site generator by default. But once you enable server-side rendering and add an adapter, a few new features become available to you.

### Per-page prerendering

Both `server` and `hybrid` modes allow for a combination of pre-rendered and server-rendered pages and endpoints. Each mode will render all pages according to their own default setting. However, both modes allow you to mark an individual page to opt-out of this default behavior.



#### Opting-in to pre-rendering in `server` mode

For a mostly server-rendered app configured as `output: server`, add `export const prerender = true` to any page or route to pre-render a static page or endpoint:

```astro title="src/pages/mypage.astro" {2}
---
export const prerender = true;
// ...
---
<html>
  <!-- Static, pre-rendered page here... -->
</html>
```

```mdx title="src/pages/mypage.mdx" {5}
---
layout: '../layouts/markdown.astro'
title: 'My page'
---
export const prerender = true;

# This is my static, pre-rendered page
```

```js title="src/pages/myendpoint.js" {1}
export const prerender = true;

export async function GET() {
  return {
    body: JSON.stringify({ message: `This is my static endpoint` }),
  };
}
```

#### Opting out of pre-rendering in `static` mode

For a mostly static site configured as `output: hybrid`, add `export const prerender = false` to any files that should be server-rendered:

```js title="src/pages/randomnumber.js" {1}
export const prerender = false;

export async function GET() {
  let number = Math.random();
  return {
    body: JSON.stringify({ number, message: `Here's a random number: ${number}` }),
  };
}
```

### `Astro.request.headers`

The headers for the request are available on `Astro.request.headers`. This works like the browser's [`Request.headers`](https://developer.mozilla.org/en-US/docs/Web/API/Request/headers). It is a [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object, a Map-like object where you can retrieve headers such as the cookie.

```astro title="src/pages/index.astro" {2}
---
const cookie = Astro.request.headers.get('cookie');
// ...
---
<html>
  <!-- Page here... -->
</html>
```

### `Astro.request.method`

The HTTP method used in the request is available as `Astro.request.method`. This works like the browser's [`Request.method`](https://developer.mozilla.org/en-US/docs/Web/API/Request/method). It returns the string representation of the HTTP method used in the request.

```astro title="src/pages/index.astro"
---
console.log(Astro.request.method) // GET (when navigated to in the browser)
---
```

:::caution
The features below are only available at the page level. (You can't use them inside of components, including layout components.)

This is because these features modify the [Response headers](https://developer.mozilla.org/en-US/docs/Glossary/Response_header), which can't be modified after they're sent to the browser.

In SSR mode, Astro uses HTML streaming to send each component to the browser as it renders them. This makes sure the user sees your HTML as fast as possible, but it also means that by the time Astro runs your component code, it has already sent the Response headers.
:::

### `Astro.cookies`

This is a utility to read and modify a single cookie. It allows you to check, set, get and delete a cookie.

See more details about [`Astro.cookies` and the `AstroCookie` type](/en/reference/api-reference/#astrocookies) in the API reference.

The example below updates the value of a cookie for a page view counter.

```astro title="src/pages/index.astro" {4,5,9}
---
let counter = 0

if (Astro.cookies.has("counter")) {
  const cookie = Astro.cookies.get("counter")
	counter = cookie.number() + 1
}

Astro.cookies.set("counter",counter)
---
<html>
  <h1>Counter = {counter}</h1>
</html>
```

### `Response`

You can also return a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) from any page. You might do this to return a 404 on a dynamic page after looking up an id in the database.

```astro title="src/pages/[id].astro" {8-11}
---
import { getProduct } from '../api';

const product = await getProduct(Astro.params.id);

// No product found
if (!product) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found'
  });
}
---
<html>
  <!-- Page here... -->
</html>
```

### Server Endpoints

A server endpoint, also known as an **API route**, is a special function exported from a `.js` or `.ts` file within the `src/pages/` folder. A powerful feature of SSR, API routes are able to securely execute code on the server.

The function takes an [endpoint context](/en/reference/api-reference/#endpoint-context) and returns a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response). 

To learn more, see our [Endpoints Guide](/en/core-concepts/endpoints/#server-endpoints-api-routes).

### Streaming

Browsers natively support HTTP streaming, where a document is broken up into chunks, sent over the network in order, and rendered on the page in that order.

During this process, browsers consume HTML incrementally: parsing, rendering into the DOM, and painting. This happens whether or not you intentionally stream your HTML. Network conditions can cause large documents to be downloaded slowly, and waiting for data fetches can block page rendering.


#### Using streaming to improve page performance

Astro's SSR uses HTML streaming to send each component to the browser when available for faster page loading. To improve your page's performance even further, you can build your components strategically to optimize their loading by avoiding blocking data fetches.

The following refactoring example demonstrates how to improve page performance by moving fetch calls to other components, moving them out of a component where they block page rendering.

The following page `await`s some data in its frontmatter. Astro will wait for all of the `fetch` calls to resolve before sending any HTML to the browser.

```astro title="src/pages/index.astro"
---
const personResponse = await fetch('https://randomuser.me/api/');
const personData = await personResponse.json();
const randomPerson = personData.results[0];
const factResponse = await fetch('https://catfact.ninja/fact');
const factData = await factResponse.json();
---
<html>
  <head>
    <title>A name and a fact</title>
  </head>
  <body>
    <h2>A name</h2>
    <p>{randomPerson.name.first}</p>
    <h2>A fact</h2>
    <p>{factData.fact}</p>
  </body>
</html>
```

Moving the `await` calls into smaller components allows you to take advantage of Astro's streaming. Using the following components to perform the data fetches, Astro can render some HTML first, such as the title, and then the paragraphs when the data is ready.

```astro title="src/components/RandomName.astro"
---
const personResponse = await fetch('https://randomuser.me/api/');
const personData = await personResponse.json();
const randomPerson = personData.results[0];
---
<p>{randomPerson.name.first}</p>
```

```astro title="src/components/RandomFact.astro"
---
const factResponse = await fetch('https://catfact.ninja/fact');
const factData = await factResponse.json();
---
<p>{factData.fact}</p>
```


The Astro page below using these components can render parts of the page sooner. The `<head>`, `<body>`, and `<h1>` tags are no longer blocked by data fetches. The server will then fetch data for `RandomName` and `RandomFact` in parallel and stream the resulting HTML to the browser.

```astro title="src/pages/index.astro"
---
import RandomName from '../components/RandomName.astro'
import RandomFact from '../components/RandomFact.astro'
---
<html>
  <head>
    <title>A name and a fact</title>
  </head>
  <body>
    <h2>A name</h2>
    <RandomName />
    <h2>A fact</h2>
    <RandomFact />
  </body>
</html>
```

#### Including Promises directly

You can also include promises directly in the template. Instead of blocking the entire component, it will resolve the promise in parallel and only block the markup that comes after it.

```astro title="src/pages/index.astro"
---
const personPromise = fetch('https://randomuser.me/api/')
  .then(response => response.json())
  .then(arr => arr[0].name.first);
const factPromise = fetch('https://catfact.ninja/fact')
  .then(response => response.json())
  .then(factData => factData.fact);
---
<html>
  <head>
    <title>A name and a fact</title>
  </head>
  <body>
    <h2>A name</h2>
    <p>{personPromise}</p>
    <h2>A fact</h2>
    <p>{factPromise}</p>
  </body>
</html>
```

In this example, `A name` will render while `personPromise` and `factPromise` are loading.
Once `personPromise` has resolved, `A fact` will appear and `factPromise` will render when it's finished loading.
